# Hashing Basics

Learn about **hash functions** and their uses in password verification and file integrity checking.

---

## Task 1: Introduction

When you download a file and want to ensure it hasn’t been modified, hashing can verify its integrity.  
By comparing the **hash values** of two files, you can confirm they are identical if their hashes match.

**Key Concept**
- A **hash value** is a fixed-size string or character sequence generated by a **hash function** from input data of any size.
- A hash function always produces the same output for identical input data.

**Learning Objectives**
- Understand hash functions and collisions  
- Learn how hashes are used in authentication systems  
- Recognize stored hash values  
- Crack hash values  
- Use hashing for integrity verification

✅ *Answer:* Let’s begin!

---

## Task 2: Hash Functions

### What is a Hash Function?
Hash functions differ from encryption — they are **one-way** and **non-reversible**.  
Given input data, a hash function outputs a **fixed-length digest** that uniquely represents that input.

**Example Commands**
```bash
md5sum file.txt
sha1sum file.txt
sha256sum file.txt
sha512sum file.txt
````

Each algorithm (MD5, SHA1, SHA256, SHA512) produces a distinct hash value for the same file.

### Why Is Hashing Important?

Hashing ensures **data integrity** and **verification**.
When logging into websites, servers compare hash values of passwords rather than storing plain text.

### Hash Collisions

A **collision** occurs when two different inputs produce the same hash output.
Modern algorithms minimize this risk, but older ones like **MD5** and **SHA1** are considered insecure.

✅ *Answers:*

* SHA256 hash of passport.jpg → `771a8c6605a8d55f67b64bcc3be749d78da15f9134d2a539a64b61f02`
* MD5 output size → `16 bytes`
* 8-bit hash has → `256 possible values`

---

## Task 3: Insecure Password Storage for Authentication

### Poor Practices

* Storing passwords in **plaintext** (e.g., RockYou.txt breach)
* Using **deprecated encryption algorithms** (e.g., Adobe breach)
* Using **insecure hash algorithms without salting** (e.g., LinkedIn breach with SHA1)

**Command Example**

```bash
head /usr/share/wordlists/rockyou.txt
```

✅ *Answer:* The 20th password in rockyou.txt is **qwerty**.

---

## Task 4: Using Hashing for Secure Password Storage

### How It Works

Instead of storing passwords, systems store **hashes** of passwords using secure algorithms.

### Rainbow Tables

A **rainbow table** maps hashes to their plaintext passwords. It’s fast but only works for unsalted hashes.

**Example Hash Lookup**

| Hash                             | Password      |
| -------------------------------- | ------------- |
| 4c5923b6a6fac7b7355f53bfe2b8f8c1 | inS3cyourP4$$ |
| 5b31f93c09ad1d065c0491b764d04933 | tryhackme     |

**Rainbow Table Tools:**

* [CrackStation.net](https://crackstation.net)
* [Hashes.com](https://hashes.com)

### Protecting Against Rainbow Tables

Use **salting** — add a unique random value to each password before hashing.

**Example (PBKDF2, Argon2, bcrypt, scrypt)**

```text
Password: AL4RMc10k
Salt: Y4UY^~{=go_!
Stored hash of AL4RMc10kY4UY^~{=go_!
```

✅ *Answers:*

* Hash `4c5923b6a6fac7b7355f53bfe2b8f8c1` = **inS3cyourP4$$**
* Hash `5b31f93c09ad1d065c0491b764d04933` = **tryhackme**
* Encrypt passwords for verification systems? → **Nay**

---

## Task 5: Recognising Password Hashes

### Linux Passwords

Stored in `/etc/shadow` (previously `/etc/passwd`) with format:

```
$prefix$options$salt$hash
```

**Common Prefixes**

| Prefix                         | Algorithm                       |
| ------------------------------ | ------------------------------- |
| `$y$`                          | yescrypt (default modern Linux) |
| `$gy$`                         | gost-yescrypt                   |
| `$s$`                          | scrypt                          |
| `$2b$`, `$2y$`, `$2a$`, `$2x$` | bcrypt                          |
| `$6$`                          | sha512crypt                     |
| `$5$`                          | sha256crypt                     |
| `$1$`                          | md5crypt                        |

**Windows Passwords**
Use **NTLM** (variant of MD4), stored in the SAM file.

✅ *Answers:*

* Yescrypt hash size → `256`
* Cisco-ASA MD5 hash mode → `2410`
* Cisco-IOS `$9$` uses → `scrypt`

---

## Task 6: Password Cracking

Password hashes are **not decrypted** — they are **cracked** by hashing candidate passwords and comparing results.

### Using Hashcat

Basic syntax:

```bash
hashcat -m <hash_type> -a <attack_mode> <hashfile> <wordlist>
```

* `-m` → hash type (e.g., 1000 = NTLM)
* `-a` → attack mode (0 = straight dictionary)
* `hashfile` → file containing the hash
* `wordlist` → list of potential passwords (e.g., rockyou.txt)

> ⚙️ **Note:** TryHackMe did not teach the `--show` flag, but it’s necessary to view cracked results after running hashcat:
>
> ```bash
> hashcat --show <hashfile>
> ```

✅ *Answers:*

* `$2a$` hash = **85208520**
* SHA256 hash = **halloween**
* bcrypt hash = **spaceman**
* hash4 = **funforyou**

---

## Task 7: Hashing for Integrity Checking

### Integrity Verification

Hashing verifies file integrity — if even a single bit changes, the hash will differ.

**Example**

```bash
sha256sum Fedora-Workstation-Live-x86_64.iso
```

Compare the output with the official SHA256 checksum.

### HMAC (Hash-based Message Authentication Code)

HMAC combines a secret key with a hashing algorithm to ensure both **authenticity** and **integrity**.

**Process Summary**

1. Pad the key to hash size.
2. XOR the padded key with `ipad` (inner pad).
3. Hash the result with the message.
4. XOR the padded key with `opad` (outer pad).
5. Hash again to produce the final HMAC.

✅ *Answers:*

* SHA256 hash of `libgcrypt-1.11.0.tar.bz2` → `09120c9867ce7120816aaa17735869b8c2f2f46136751aae47d81f58685b59c`
* Hashcat mode number for HMAC-SHA512 (key = pass) → `1750`

---

## Task 8: Conclusion

### Distinguishing Concepts

| Concept        | Description                                                                    |
| -------------- | ------------------------------------------------------------------------------ |
| **Hashing**    | One-way process that turns data into a fixed-size digest (non-reversible).     |
| **Encoding**   | Converts data for compatibility (e.g., Base64); reversible, not secure.        |
| **Encryption** | Two-way process for securing data using keys; reversible with the correct key. |

**Example**

```bash
base64 TryHackMe
base64 -d VHJ5SGFja01lCg==
```

> ⚙️ **Note:** TryHackMe didn’t show how to decode a file — the correct command to decode from a file is:
>
> ```bash
> base64 -d decode-this.txt
> ```

✅ *Answer:* Decoded word from base64 file = **ENcodeDEcode**

---

## Key Takeaways

* **Hashing** → Verifies integrity, authenticates passwords (one-way).
* **Salting** → Adds randomness to prevent rainbow table attacks.
* **HMAC** → Ensures authenticity and integrity using a key and hash function.
* **Hashcat** → Cracks password hashes by comparing against wordlists.
* **Base64** → Encodes/decodes data (not encryption).
* **Secure Hashing** → Use Argon2, bcrypt, scrypt, or PBKDF2 for modern password storage.

