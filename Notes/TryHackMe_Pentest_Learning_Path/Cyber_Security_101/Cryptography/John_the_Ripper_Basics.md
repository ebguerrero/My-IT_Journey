# ğŸ§© John the Ripper: The Basics

## ğŸ§  Learning Objectives

By the end of this room, you will understand:

* How John the Ripper (JtR) identifies and cracks hashes.
* How to use wordlists, single-crack, and rule-based attacks.
* How to convert hashes from various file types (ZIP, RAR, SSH).
* How to create and test **custom cracking rules**.
* How to use `--show` to display cracked results clearly.

---

## ğŸ§© Task 1 â€“ Introduction

John the Ripper (JtR) is a **well-known password-cracking tool** supporting a vast range of hash types and formats.
Itâ€™s extremely efficient and often used in both **penetration testing** and **CTF (Capture-the-Flag)** environments.

**Prerequisites:**

* Cryptography Basics
* Public Key Cryptography Basics
* Hashing Basics

**You will learn how to:**

* Crack Windows authentication hashes.
* Crack `/etc/shadow` hashes.
* Crack password-protected ZIP and RAR files.
* Crack SSH private keys.

---

## ğŸ§© Task 2 â€“ Basic Terms

### ğŸ”¹ What Are Hashes?

A **hash** is a fixed-length representation of data, produced by hashing algorithms such as **MD4, MD5, SHA1, or NTLM**.
The process is one-way: it cannot (feasibly) be reversed.

Example:

```bash
echo -n "polo" | md5sum
# b5379f56e692d7af11b579d3946d4a
```

### ğŸ”¹ What Makes Hashes Secure?

Good hash functions are:

* **One-way** â€“ canâ€™t reverse to original data.
* **Deterministic** â€“ same input always produces same output.
* **Collision-resistant** â€“ no two different inputs yield the same hash easily.

### ğŸ”¹ Where John Comes In

John uses **dictionary attacks** and **brute-force** techniques to find plaintext passwords that produce matching hashes.

ğŸ§© **Answer:**
Most popular extended version of John â†’ **Jumbo John**

---

## ğŸ§© Task 3 â€“ Setting Up Your System

### ğŸ”¹ Installation Notes

If using the TryHackMe AttackBox or Kali Linux, **Jumbo John** is preinstalled.

Check version:

```bash
john
# John the Ripper 1.9.0-jumbo-1 [..]
```

If not installed:

```bash
sudo apt install john -y
```

### ğŸ”¹ Wordlists

The most common wordlist is **rockyou.txt**, created from a breached database in 2009:

```bash
/usr/share/wordlists/rockyou.txt
```

ğŸ§© **Answer:** rockyou.com

---

## ğŸ§© Task 4 â€“ Cracking Basic Hashes

### ğŸ”¹ Syntax

```bash
john [options] [file]
```

**Example usage:**

```bash
john --wordlist=/usr/share/wordlists/rockyou.txt hash_to_crack.txt
```

### ğŸ”¹ Identify Hash Type

If John doesnâ€™t auto-detect the format, use:

```bash
python3 hash-id.py
```

This tool tells you likely hash formats.

### ğŸ”¹ Format-Specific Example

```bash
john --format=raw-md5 --wordlist=/usr/share/wordlists/rockyou.txt hash_to_crack.txt
```

### ğŸ§© Practical

| Hash File | Type      | Cracked Value |
| --------- | --------- | ------------- |
| hash1.txt | md5       | biscuit       |
| hash2.txt | sha1      | kangeroo      |
| hash3.txt | sha256    | microphone    |
| hash4.txt | whirlpool | colossal      |

ğŸ§  **Pro Tip:**
After cracking, always use:

```bash
john --show --format=<format> <hashfile>
```

to display **cracked usernameâ€“password pairs**.

---

## ğŸ§© Task 5 â€“ Cracking Windows Authentication Hashes

Windows systems use **NTHash / NTLM** to store user credentials.

### ğŸ”¹ Syntax

```bash
john --format=nt --wordlist=/usr/share/wordlists/rockyou.txt ntlm.txt
```

ğŸ§© **Answers:**

* Format flag: `--format=nt`
* Cracked password: `mushroom`

---

## ğŸ§© Task 6 â€“ Cracking /etc/shadow Hashes

### ğŸ”¹ Combine passwd and shadow Files

```bash
unshadow local_passwd local_shadow > unshadowed.txt
```

### ğŸ”¹ Crack the Result

```bash
john --wordlist=/usr/share/wordlists/rockyou.txt --format=sha512crypt unshadowed.txt
```

ğŸ§© **Answer:** root password â†’ `1234`

---

## ğŸ§© Task 7 â€“ Single Crack Mode

### ğŸ”¹ Overview

In **Single Crack Mode**, John generates guesses based on usernames and GECOS fields (e.g., â€œMarkusâ€ â†’ Markus1, M4rkus!, etc.).

### ğŸ”¹ Syntax

```bash
john --single --format=raw-sha256 hashes.txt
```

ğŸ§© **Answer:** Jokerâ€™s password â†’ `JoKr`

---

## ğŸ§© Task 8 â€“ Custom Rules

### ğŸ”¹ Why Use Rules

Custom rules allow advanced wordlist modification to simulate **human password patterns** and exploit **password-complexity predictability**.

### ğŸ”¹ Example Rule

```bash
[List.Rules:PoloPassword]
Az"[0-9][!@#]"
```

**Explanation:**

* `A` â†’ append characters
* `z` â†’ capitalize first letter
* `[0-9]` â†’ append numbers 0-9
* `[!@#]` â†’ append symbols `!`, `@`, `#`

You can run it like:

```bash
john --wordlist=/usr/share/wordlists/rockyou.txt --rule=PoloPassword hash.txt
```

### ğŸ§  **Answer Summary**

* Exploit: password complexity predictability
* Append rule: `Az"[A-Z]"`
* Custom rule flag: `--rule=THMRules`

---

### âš™ï¸ **Hands-On Example: Building and Testing a Custom Rule (FULLY COMMENTED)**

Below is the fully commented, ready-to-run mini-lab. Every line includes a `#` comment explaining what it does. Copy/paste into a terminal in your lab VM and run step by step.

```bash
# ----------------------------
# John the Ripper â€” Custom Rule Lab (fully commented)
# ----------------------------

# 1) create a workspace and move into it
mkdir -p ~/john-custom-rules            # make a workspace directory (no error if it already exists)
cd ~/john-custom-rules                 # change into the workspace directory

# 2) create a tiny base wordlist (one candidate per line)
printf "polopassword\nadmin\npassword\n" > base.txt
# printf ... > base.txt   : write three test words into base.txt (overwrite any existing file)

# 3) create a local john config that defines a custom rule named DemoRule
cat <<'EOF' > john-local.conf
# john-local.conf - local-only rules for testing
# Format: [List.Rules:<RuleName>]
# Below lines are John rule commands. Comments here are for human readers only.
[List.Rules:DemoRule]
# Rule explanation (each token does something during rule expansion):
#  c        -> capitalize the first character of the word (polopassword -> Polopassword)
#  A        -> append following quoted string / expansions to the end of the word
#  z        -> toggle capitalization (used here to demonstrate chaining; often redundant with c)
#  "..."    -> quoted string containing literal chars or class expansions (e.g., [0-9])
#  [0-9]    -> class placeholder representing digits 0 through 9 (John expands these)
#  [!@#]    -> class placeholder representing symbols !, @, #
# Combined: capitalize first char, then append a digit and a symbol (e.g., Polopassword5!)
cAz"[0-9][!@#]"
EOF
# john-local.conf written with DemoRule and inline comments for clarity

# 4) create a test hash corresponding to the plain text "Polopassword5!"
#    We use md5 here for simplicity (John supports raw-md5); real labs may use other formats.
echo -n "Polopassword5!" | md5sum | awk '{print $1}' > testhash.txt
# echo -n ...      : print the exact string without a newline (important for consistent hashing)
# md5sum           : compute the MD5 digest of input and print "<digest>  -"
# awk '{print $1}'  : extract the hex digest only (first field)
# > testhash.txt    : save the digest to testhash.txt (John expects one hash per line)

# 5) quick preview of files to confirm setup
echo "base.txt (wordlist):"
cat base.txt                          # show the short wordlist content
echo
echo "testhash.txt (target hash):"
cat testhash.txt                      # show the target hash contents
echo
echo "john-local.conf (rules):"
sed -n '1,200p' john-local.conf       # print the john-local.conf file so you can verify the rule
echo

# 6) run John using the local config and the DemoRule
#    --config= : explicitly point John at the local john-local.conf so it sees DemoRule
#    --rules=DemoRule : use the DemoRule defined above
#    --wordlist=base.txt : supply the small base wordlist as the starting point
#    --format=raw-md5 : declare the hash algorithm explicitly (avoid mis-detection)
john --wordlist=base.txt --rules=DemoRule --format=raw-md5 testhash.txt --config=john-local.conf
# Note: John will expand base.txt using DemoRule and attempt generated candidates against the hash

# 7) once John finishes (or while running), view cracked results with --show
john --show --format=raw-md5 testhash.txt
# --show : display any cracked username:password mappings stored in John's pot file (no re-cracking)
# If Polopassword5! was generated and matched the hash, John will list it here

# 8) optional: inspect the potfile (John's store of cracked hashes)
#    The potfile contains hash:password pairs; show the last 20 entries for quick verification
tail -n 20 ~/.john/john.pot 2>/dev/null || echo "no potfile or no permissions to access it"

# 9) cleanup (optional) â€” uncomment to remove test artifacts if you want to reset the lab
# rm -f testhash.txt base.txt john-local.conf
# cd ~
# rmdir ~/john-custom-rules  # only removes if directory is empty
```

**How the rule expands (what John will try)**

* Start with `polopassword` from `base.txt`.
* `c` â†’ `Polopassword` (capitalize first letter).
* `A z "[0-9][!@#]"` â†’ append combinations: `Polopassword0!`, `Polopassword0@`, ..., `Polopassword9#`.
* If target is `Polopassword5!`, John will find it using that expansion.

**Notes**

* The quoted syntax `"..."` in John rules can include class expansions; itâ€™s not always literal text.
* If John fails to find the password, increase verbosity (`--verbosity=5`), use larger lists (e.g., `rockyou.txt`), or try incremental mode.
* Use `john --list=rules` to explore available rule tokens; Jumbo John docs have the complete language.

---

## ğŸ§© Task 9 â€“ Cracking Password-Protected ZIP Files

### ğŸ”¹ Convert ZIP to Hash

```bash
zip2john zipfile.zip > zip_hash.txt
```

### ğŸ”¹ Crack the Hash

```bash
john --wordlist=/usr/share/wordlists/rockyou.txt zip_hash.txt
john --show zip_hash.txt
```

ğŸ§© **Answers:**

* Password â†’ `pass123`
* Flag â†’ `THM{w3ll_d0n3_h4sh_r0y4l}`

---

## ğŸ§© Task 10 â€“ Cracking Password-Protected RAR Files

### ğŸ”¹ Convert RAR to Hash

```bash
rar2john rarfile.rar > rar_hash.txt
```

### ğŸ”¹ Crack

```bash
john --wordlist=/usr/share/wordlists/rockyou.txt rar_hash.txt
john --show rar_hash.txt
```

ğŸ§© **Answers:**

* Password â†’ `password`
* Flag â†’ `THM{r4r_4rch1ve5_th15_t1m3}`

---

## ğŸ§© Task 11 â€“ Cracking SSH Keys

### ğŸ”¹ Convert Private Key to Hash

```bash
/opt/john/ssh2john.py id_rsa > id_rsa_hash.txt
```

### ğŸ”¹ Crack It

```bash
john --wordlist=/usr/share/wordlists/rockyou.txt id_rsa_hash.txt
john --show id_rsa_hash.txt
```

ğŸ§© **Answer:** SSH key password â†’ `mango`

---

## ğŸ§© Task 12 â€“ Further Reading

Congratulations! Youâ€™ve completed the **John the Ripper: The Basics** room.
Continue exploring advanced topics like:

* Incremental mode
* Hybrid rulechains
* GPU acceleration (OpenCL builds)

ğŸ“˜ **Recommended Reading:** [Openwall Wiki â€“ John the Ripper](https://www.openwall.com/john/)

---

## âš ï¸ Supplementary Notes & Caveats

### ğŸ”¸ `--show` Command Not Covered in TryHackMe

TryHackMe does not emphasize `--show`, but itâ€™s **critical** for viewing results post-crack:

```bash
john --show --format=<format> <hashfile>
```

Displays cracked credentials directly without re-cracking.

### ğŸ”¸ Missing Rule Practice in Lesson

TryHackMe introduces the concept of **custom rules** but doesnâ€™t include hands-on implementation.
The **Custom Rules Practice Lab** above fills that gap, showing actual syntax and a runnable test workflow.
